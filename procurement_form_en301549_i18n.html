<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced EN 301 549 - Global ICT Accessibility Requirements</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 10px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #0056b3;
            margin-block-start: 0;
            margin-block-end: 0;
        }
        .form-section {
            margin-bottom: 20px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .form-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #0056b3;
        }
        #output {
            margin-top: 30px;
            padding: 15px;
            background-color: #e2eafc;
            border: 1px solid #c2d9f7;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #000;
        }
        .error-message {
            color: red;
            font-size: 0.9em;
            margin-top: 5px;
            display: none;
        }
        input:invalid:not(:placeholder-shown) {
            border-color: red;
        }
        input:focus,
        textarea:focus,
        button:focus,
        select:focus {
            outline: 2px solid #005fcc;
            outline-offset: 2px;
        }
        .form-section input[type="text"],
        .form-section input[type="url"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .form-section input[type="checkbox"],
        .form-section input[type="radio"] {
            margin-right: 8px;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: flex-end; margin-top: 20px;">
            <label for="langSwitcher" style="font-weight: bold; margin-right: 10px;">üåê <span id="langLabel">Language</span>:</label>
            <select id="langSwitcher" aria-label="Language switcher" style="font-size: 1em; padding: 4px 8px;">
                <option value="en">English</option>
                <option value="fr">Fran√ßais</option>
            </select>
        </div>
        <form id="procurementForm">
            <div id="formSection"></div>
            <div id="output" role="region" aria-live="polite" aria-label="Generated requirements"></div>
        </form>
    </div>

<p><a href="https://mgifford.github.io/caart/">CAART Site</a></p>


    <script>
        // --- TRANSLATIONS OBJECT ---
        const translations = {
            en: {
                langName: "English",
                langLabel: "Language",
                skipLink: "Skip to main content",
                projectName: "Project Name",
                projectNamePlaceholder: "Enter project name...",
                procurementPhase: "Procurement Phase",
                procurementPhases: {
                    projectPlanning: "Requirements Planning",
                    marketResearch: "Market Research",
                    tenderDevelopment: "Tender Development",
                    evaluation: "Evaluation & Testing"
                },
                ictType: "ICT Type(s)",
                ictTypes: {
                    webSoftware: "Web Content / Software",
                    documents: "Electronic Documents",
                    hardware: "Hardware",
                    telecom: "Telecommunications / Video",
                    support: "Support & Documentation"
                },
                exemption: "Exemption/Exception",
                exemptions: {
                    none: "No Exemption",
                    legacy: "Legacy System",
                    commercial: "Commercial Off-the-Shelf (COTS)",
                    other: "Other"
                },
                webContent: "Will this procurement include web content?",
                yes: "Yes",
                no: "No",
                wcagLevel: "WCAG Level",
                wcagLevels: {
                    AA: "AA",
                    AAA: "AAA"
                },
                publicWebsite: "Is this a public website?",
                softwareType: "Software Application Type(s)",
                softwareTypes: {
                    web: "Web Application",
                    desktop: "Desktop Application",
                    mobile: "Mobile Application",
                    authoring: "Authoring Tool"
                },
                hardwareCategory: "Hardware Category(ies)",
                hardwareCategories: {
                    desktop: "Desktop Computer",
                    mobile: "Mobile Device",
                    peripheral: "Peripheral Device",
                    telecom: "Telecommunications Equipment"
                },
                closedFunctionality: "Does the hardware have closed functionality?",
                videoType: "Video/Audio Content Type(s)",
                videoTypes: {
                    live: "Live Video/Audio",
                    preRecorded: "Pre-recorded Video/Audio"
                },
                mediaRequirement: "Media Accessibility Requirements",
                mediaRequirements: {
                    captions: "Captions",
                    audioDescription: "Audio Description",
                    transcripts: "Transcripts"
                },
                supportType: "Support & Documentation Type(s)",
                supportTypes: {
                    documentation: "Documentation",
                    relayServices: "Relay Services",
                    accessibilitySupport: "Accessibility Support"
                },
                authoringCapability: "Authoring Tool Accessibility Capability",
                authoringCapabilities: {
                    accessible: "Produces accessible content by default",
                    prompt: "Prompts for accessibility info",
                    check: "Checks/repairs accessibility",
                    support: "Supports accessibility throughout"
                },
                websiteURL: "Website URL (if applicable)",
                saveData: "Save Form Data",
                loadData: "Load Form Data",
                requiredField: "This field is required.",
                missingFields: "Some required fields are missing or incomplete. Please review the form and try again.",
                generateRequirements: "Generate Requirements",
                noneOption: "None of the above",
                noneOption: "None of the above"
            },
            fr: {
                langName: "Fran√ßais",
                langLabel: "Langue",
                skipLink: "Aller au contenu principal",
                projectName: "Nom du projet",
                projectNamePlaceholder: "Entrez le nom du projet...",
                procurementPhase: "Phase d'approvisionnement",
                procurementPhases: {
                    projectPlanning: "Planification des exigences",
                    marketResearch: "√âtude de march√©",
                    tenderDevelopment: "√âlaboration de l'appel d'offres",
                    evaluation: "√âvaluation et tests"
                },
                ictType: "Type(s) TIC",
                ictTypes: {
                    webSoftware: "Contenu Web / Logiciel",
                    documents: "Documents √©lectroniques",
                    hardware: "Mat√©riel",
                    telecom: "T√©l√©communications / Vid√©o",
                    support: "Soutien et documentation"
                },
                exemption: "Exemption/Exception",
                exemptions: {
                    none: "Aucune exemption",
                    legacy: "Syst√®me h√©rit√©",
                    commercial: "Produit commercial pr√™t √† l'emploi (COTS)",
                    other: "Autre"
                },
                webContent: "Cet achat comprend-il du contenu Web?",
                yes: "Oui",
                no: "Non",
                wcagLevel: "Niveau WCAG",
                wcagLevels: {
                    AA: "AA",
                    AAA: "AAA"
                },
                publicWebsite: "S'agit-il d'un site Web public?",
                softwareType: "Type(s) d'application logicielle",
                softwareTypes: {
                    web: "Application Web",
                    desktop: "Application de bureau",
                    mobile: "Application mobile",
                    authoring: "Outil d'√©dition"
                },
                hardwareCategory: "Cat√©gorie(s) de mat√©riel",
                hardwareCategories: {
                    desktop: "Ordinateur de bureau",
                    mobile: "Appareil mobile",
                    peripheral: "P√©riph√©rique",
                    telecom: "√âquipement de t√©l√©communications"
                },
                closedFunctionality: "Le mat√©riel a-t-il une fonctionnalit√© ferm√©e?",
                videoType: "Type(s) de contenu vid√©o/audio",
                videoTypes: {
                    live: "Vid√©o/Audio en direct",
                    preRecorded: "Vid√©o/Audio pr√©enregistr√©"
                },
                mediaRequirement: "Exigences d'accessibilit√© des m√©dias",
                mediaRequirements: {
                    captions: "Sous-titres",
                    audioDescription: "Description audio",
                    transcripts: "Transcriptions"
                },
                supportType: "Type(s) de soutien et documentation",
                supportTypes: {
                    documentation: "Documentation",
                    relayServices: "Services de relais",
                    accessibilitySupport: "Soutien √† l'accessibilit√©"
                },
                authoringCapability: "Capacit√© d'accessibilit√© de l'outil d'√©dition",
                authoringCapabilities: {
                    accessible: "Produit du contenu accessible par d√©faut",
                    prompt: "Invite √† fournir des informations sur l'accessibilit√©",
                    check: "V√©rifie/r√©pare l'accessibilit√©",
                    support: "Soutient l'accessibilit√© tout au long du processus"
                },
                websiteURL: "URL du site Web (le cas √©ch√©ant)",
                saveData: "Enregistrer les donn√©es du formulaire",
                loadData: "Charger les donn√©es du formulaire",
                requiredField: "Ce champ est requis.",
                missingFields: "Certains champs obligatoires sont manquants ou incomplets. Veuillez v√©rifier le formulaire et r√©essayer.",
                generateRequirements: "G√©n√©rer les exigences",
                noneOption: "Aucune des options ci-dessus",
                noneOption: "Aucune des options ci-dessus"
            }
        };

        // --- GLOBAL STATE ---
        let currentLang = 'en';

        // --- RENDERING FUNCTIONS ---
        function renderForm() {
            const t = translations[currentLang];
            document.getElementById('langLabel').textContent = t.langLabel;
            document.getElementById('langSwitcher').value = currentLang;
            document.documentElement.lang = currentLang;

            // Start rendering the form dynamically
            let html = '';
            
            // Title
            html += `<h1>EN 301 549 - Global ICT Accessibility Requirements</h1>`;
            
            // Project name field with default value
            html += `<div class="form-section">`;
            html += `<label for="projectName">${t.projectName} *</label>`;
            html += `<input type="text" id="projectName" name="projectName" placeholder="${t.projectNamePlaceholder}" style="width: 100%; max-width: 400px; margin-bottom: 10px;" required value="ICT Accessibility Assessment">`;
            html += `<div id="projectNameError" class="error-message">${t.requiredField}</div>`;
            html += `</div>`;
            
            // Procurement phase field with default
            html += `<div class="form-section">`;
            html += `<h2>Procurement Phase</h2>`;
            html += `<label>${t.procurementPhase} *</label>`;
            html += `<div style="display: flex; flex-wrap: wrap; gap: 20px;">`;
            Object.entries(t.procurementPhases).forEach(([key, value]) => {
                const checked = key === 'tenderDevelopment' ? ' checked' : '';
                html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
                html += `<input type="radio" name="procurementPhase" value="${key}" style="margin-right: 8px;"${checked}>`;
                html += `<span>${value}</span>`;
                html += `</label>`;
            });
            html += `</div></div>`;
            
            // ICT Type field
            html += `<div class="form-section">`;
            html += `<h2>ICT Type</h2>`;
            html += `<label>${t.ictType} *</label>`;
            html += `<div style="display: flex; flex-wrap: wrap; gap: 20px;">`;
            Object.entries(t.ictTypes).forEach(([key, value]) => {
                html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
                html += `<input type="checkbox" name="ictType" value="${key}" style="margin-right: 8px;">`;
                html += `<span>${value}</span>`;
                html += `</label>`;
            });
            html += `</div></div>`;
            
            // Exemption field with default
            html += `<div class="form-section">`;
            html += `<h2>Exemptions & Exceptions</h2>`;
            html += `<label>${t.exemption} *</label>`;
            html += `<div style="display: flex; flex-wrap: wrap; gap: 20px;">`;
            Object.entries(t.exemptions).forEach(([key, value]) => {
                const checked = key === 'none' ? ' checked' : '';
                html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
                html += `<input type="radio" name="exemption" value="${key}" style="margin-right: 8px;"${checked}>`;
                html += `<span>${value}</span>`;
                html += `</label>`;
            });
            html += `</div></div>`;
            
            // Web Content field with default
            html += `<div class="form-section">`;
            html += `<label>${t.webContent} *</label>`;
            html += `<div style="display: flex; gap: 20px;">`;
            html += `<label style="display: flex; align-items: center;">`;
            html += `<input type="radio" name="webContent" value="yes" style="margin-right: 8px;" checked>`;
            html += `<span>${t.yes}</span>`;
            html += `</label>`;
            html += `<label style="display: flex; align-items: center;">`;
            html += `<input type="radio" name="webContent" value="no" style="margin-right: 8px;">`;
            html += `<span>${t.no}</span>`;
            html += `</label>`;
            html += `</div></div>`;
            
            // WCAG Level field (conditional)
            html += `<div class="form-section" id="wcagLevelSection" style="display: none;">`;
            html += `<label>${t.wcagLevel} *</label>`;
            html += `<div style="display: flex; gap: 20px;">`;
            Object.entries(t.wcagLevels).forEach(([key, value]) => {
                html += `<label style="display: flex; align-items: center;">`;
                html += `<input type="radio" name="wcagLevel" value="${key}" style="margin-right: 8px;">`;
                html += `<span>${value}</span>`;
                html += `</label>`;
            });
            html += `</div></div>`;
            
            // Public Website field (conditional)
            html += `<div class="form-section" id="publicWebsiteSection" style="display: none;">`;
            html += `<label>${t.publicWebsite} *</label>`;
            html += `<div style="display: flex; gap: 20px;">`;
            html += `<label style="display: flex; align-items: center;">`;
            html += `<input type="radio" name="publicWebsite" value="yes" style="margin-right: 8px;">`;
            html += `<span>${t.yes}</span>`;
            html += `</label>`;
            html += `<label style="display: flex; align-items: center;">`;
            html += `<input type="radio" name="publicWebsite" value="no" style="margin-right: 8px;">`;
            html += `<span>${t.no}</span>`;
            html += `</label>`;
            html += `</div>`;
            
            // Website URL field (conditional)
            html += `<div id="websiteInputContainer" style="display: none; margin-top: 10px;">`;
            html += `<label for="websiteURL">${t.websiteURL}</label>`;
            html += `<input type="url" id="websiteURL" name="websiteURL" style="width: 100%; max-width: 400px; margin-top: 5px;" placeholder="https://example.com">`;
            html += `</div>`;
            html += `</div>`;
            
            // Software Application Types
            html += `<div class="form-section">`;
            html += `<h2>Software</h2>`;
            html += `<label>${t.softwareType} *</label>`;
            html += `<div style="display: flex; flex-wrap: wrap; gap: 20px;">`;
            Object.entries(t.softwareTypes).forEach(([key, value]) => {
                html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
                html += `<input type="checkbox" name="softwareType" value="${key}" style="margin-right: 8px;">`;
                html += `<span>${value}</span>`;
                html += `</label>`;
            });
            html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
            html += `<input type="checkbox" name="softwareType" value="none" style="margin-right: 8px;" checked>`;
            html += `<span>${t.noneOption}</span>`;
            html += `</label>`;
            html += `</div></div>`;
            
            // Authoring Tool Capability (conditional)
            html += `<div class="form-section" id="authoringToolRequirements" style="display: none;">`;
            html += `<label>${t.authoringCapability}</label>`;
            html += `<div style="display: flex; flex-wrap: wrap; gap: 20px;">`;
            Object.entries(t.authoringCapabilities).forEach(([key, value]) => {
                html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
                html += `<input type="radio" name="authoringCapability" value="${key}" style="margin-right: 8px;">`;
                html += `<span>${value}</span>`;
                html += `</label>`;
            });
            html += `</div></div>`;
            
            // Hardware Categories
            html += `<div class="form-section">`;
            html += `<h2>Hardware</h2>`;
            html += `<label>${t.hardwareCategory} *</label>`;
            html += `<div style="display: flex; flex-wrap: wrap; gap: 20px;">`;
            Object.entries(t.hardwareCategories).forEach(([key, value]) => {
                html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
                html += `<input type="checkbox" name="hardwareCategory" value="${key}" style="margin-right: 8px;">`;
                html += `<span>${value}</span>`;
                html += `</label>`;
            });
            html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
            html += `<input type="checkbox" name="hardwareCategory" value="none" style="margin-right: 8px;" checked>`;
            html += `<span>${t.noneOption}</span>`;
            html += `</label>`;
            html += `</div></div>`;
            
            // Closed Functionality (conditional)
            html += `<div class="form-section" id="closedFunctionalityQuestion" style="display: none;">`;
            html += `<label>${t.closedFunctionality}</label>`;
            html += `<div style="display: flex; gap: 20px;">`;
            html += `<label style="display: flex; align-items: center;">`;
            html += `<input type="radio" name="closedFunctionality" value="yes" style="margin-right: 8px;">`;
            html += `<span>${t.yes}</span>`;
            html += `</label>`;
            html += `<label style="display: flex; align-items: center;">`;
            html += `<input type="radio" name="closedFunctionality" value="no" style="margin-right: 8px;">`;
            html += `<span>${t.no}</span>`;
            html += `</label>`;
            html += `</div></div>`;
            
            // Video/Audio Content Types
            html += `<div class="form-section">`;
            html += `<h2>Media & Telecommunications</h2>`;
            html += `<label>${t.videoType} *</label>`;
            html += `<div style="display: flex; flex-wrap: wrap; gap: 20px;">`;
            Object.entries(t.videoTypes).forEach(([key, value]) => {
                html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
                html += `<input type="checkbox" name="videoType" value="${key}" style="margin-right: 8px;">`;
                html += `<span>${value}</span>`;
                html += `</label>`;
            });
            html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
            html += `<input type="checkbox" name="videoType" value="none" style="margin-right: 8px;" checked>`;
            html += `<span>${t.noneOption}</span>`;
            html += `</label>`;
            html += `</div></div>`;
            
            // Media Requirements (conditional)
            html += `<div class="form-section" id="captioningRequirements" style="display: none;">`;
            html += `<label>${t.mediaRequirement}</label>`;
            html += `<div style="display: flex; flex-wrap: wrap; gap: 20px;">`;
            Object.entries(t.mediaRequirements).forEach(([key, value]) => {
                html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
                html += `<input type="checkbox" name="mediaRequirements" value="${key}" style="margin-right: 8px;">`;
                html += `<span>${value}</span>`;
                html += `</label>`;
            });
            html += `</div></div>`;
            
            // Support & Documentation Types
            html += `<div class="form-section">`;
            html += `<h2>Support Documentation & Services</h2>`;
            html += `<label>${t.supportType} *</label>`;
            html += `<div style="display: flex; flex-wrap: wrap; gap: 20px;">`;
            Object.entries(t.supportTypes).forEach(([key, value]) => {
                html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
                html += `<input type="checkbox" name="supportType" value="${key}" style="margin-right: 8px;">`;
                html += `<span>${value}</span>`;
                html += `</label>`;
            });
            html += `<label style="display: flex; align-items: center; margin-bottom: 5px;">`;
            html += `<input type="checkbox" name="supportType" value="none" style="margin-right: 8px;" checked>`;
            html += `<span>${t.noneOption}</span>`;
            html += `</label>`;
            html += `</div></div>`;
            
            // Buttons section
            html += `<div style="margin-top: 20px;">`;
            html += `<button type="submit">${t.generateRequirements}</button>`;
            html += `<button type="button" id="saveDataBtn" style="margin-left: 10px;">${t.saveData}</button>`;
            html += `<button type="button" id="loadDataBtn" style="margin-left: 10px;">${t.loadData}</button>`;
            html += `<input type="file" id="fileInput" style="display:none;" accept="application/json">`;
            html += `</div>`;

            document.getElementById('formSection').innerHTML = html;
            
            // After rendering, set up event handlers for conditional display
            setupEventHandlers();
        }

        // --- EVENT HANDLERS AND CONDITIONAL DISPLAY ---
        function setupEventHandlers() {
            // Add event listeners for conditional displays
            document.querySelectorAll('input[name="webContent"]').forEach(radio => {
                radio.addEventListener('change', updateConditionalDisplays);
            });
            
            document.querySelectorAll('input[name="publicWebsite"]').forEach(radio => {
                radio.addEventListener('change', updateConditionalDisplays);
            });
            
            document.querySelectorAll('input[name="softwareType"]').forEach(checkbox => {
                checkbox.addEventListener('change', updateConditionalDisplays);
            });
            
            document.querySelectorAll('input[name="hardwareCategory"]').forEach(checkbox => {
                checkbox.addEventListener('change', updateConditionalDisplays);
            });
            
            document.querySelectorAll('input[name="videoType"]').forEach(checkbox => {
                checkbox.addEventListener('change', updateConditionalDisplays);
            });
            
            // Set up form submission
            document.getElementById('procurementForm').addEventListener('submit', handleFormSubmission);
            
            // Set up save/load functionality
            document.getElementById('saveDataBtn').addEventListener('click', saveFormData);
            document.getElementById('loadDataBtn').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            document.getElementById('fileInput').addEventListener('change', loadFormData);
            
            // Initial conditional display update
            updateConditionalDisplays();
        }
        
        function updateConditionalDisplays() {
            // Show WCAG and public website sections if web content is selected
            const webContentSelected = document.querySelector('input[name="webContent"][value="yes"]')?.checked;
            const wcagSection = document.getElementById('wcagLevelSection');
            const publicWebsiteSection = document.getElementById('publicWebsiteSection');
            
            if (wcagSection) wcagSection.style.display = webContentSelected ? 'block' : 'none';
            if (publicWebsiteSection) publicWebsiteSection.style.display = webContentSelected ? 'block' : 'none';
            
            // Show website URL input if public website is selected
            const publicWebsite = document.querySelector('input[name="publicWebsite"][value="yes"]')?.checked;
            const websiteInputContainer = document.getElementById('websiteInputContainer');
            if (websiteInputContainer) websiteInputContainer.style.display = publicWebsite ? 'block' : 'none';
            
            // Show authoring tool requirements if authoring tools are selected
            const authoringSelected = document.querySelector('input[name="softwareType"][value="authoring"]')?.checked;
            const authoringToolRequirements = document.getElementById('authoringToolRequirements');
            if (authoringToolRequirements) authoringToolRequirements.style.display = authoringSelected ? 'block' : 'none';
            
            // Show closed functionality question if hardware is selected
            const hardwareSelected = Array.from(document.querySelectorAll('input[name="hardwareCategory"]:checked'))
                .some(cb => cb.value !== 'none');
            const closedFunctionalityQuestion = document.getElementById('closedFunctionalityQuestion');
            if (closedFunctionalityQuestion) closedFunctionalityQuestion.style.display = hardwareSelected ? 'block' : 'none';
            
            // Show captioning requirements if video/audio is selected
            const mediaSelected = Array.from(document.querySelectorAll('input[name="videoType"]:checked'))
                .some(cb => cb.value !== 'none');
            const captioningRequirements = document.getElementById('captioningRequirements');
            if (captioningRequirements) captioningRequirements.style.display = mediaSelected ? 'block' : 'none';
        }
        
        // --- URL PARAMETER HANDLING ---
        function populateFormFromURL() {
            const urlParams = new URLSearchParams(window.location.search);

            // Project Name
            if (urlParams.has('projectName')) {
                const projectNameInput = document.getElementById('projectName');
                if (projectNameInput) {
                    projectNameInput.value = urlParams.get('projectName');
                }
            }

            // Radio Buttons
            const radioGroups = ['procurementPhase', 'exemption', 'webContent', 'wcagLevel', 'publicWebsite', 'authoringCapability', 'closedFunctionality'];
            radioGroups.forEach(groupName => {
                if (urlParams.has(groupName)) {
                    const value = urlParams.get(groupName);
                    const radio = document.querySelector(`input[name="${groupName}"][value="${value}"]`);
                    if (radio) {
                        radio.checked = true;
                        radio.dispatchEvent(new Event('change'));
                    }
                }
            });

            // Checkboxes - handle multiple values
            const checkboxGroups = ['ictType', 'softwareType', 'hardwareCategory', 'videoType', 'mediaRequirements', 'supportType'];
            checkboxGroups.forEach(groupName => {
                // First, uncheck all in the group
                document.querySelectorAll(`input[name="${groupName}"]`).forEach(checkbox => {
                    checkbox.checked = false;
                });

                if (urlParams.has(groupName)) {
                    const values = urlParams.getAll(groupName);
                    values.forEach(value => {
                        const checkbox = document.querySelector(`input[name="${groupName}"][value="${value}"]`);
                        if (checkbox) {
                            checkbox.checked = true;
                            checkbox.dispatchEvent(new Event('change'));
                        }
                    });
                }
            });

            // Website URL
            if (urlParams.has('websiteURL')) {
                const websiteURLInput = document.getElementById('websiteURL');
                if (websiteURLInput) {
                    websiteURLInput.value = urlParams.get('websiteURL');
                }
            }
        }

        function updateURLFromForm() {
            const formData = collectFormData();
            const urlParams = new URLSearchParams();

            // Add project name
            if (formData.projectName) {
                urlParams.set('projectName', formData.projectName);
            }

            // Add radio button values
            const radioFields = ['procurementPhase', 'exemption', 'webContent', 'wcagLevel', 'publicWebsite', 'authoringCapability', 'closedFunctionality'];
            radioFields.forEach(field => {
                if (formData[field]) {
                    urlParams.set(field, formData[field]);
                }
            });

            // Add checkbox arrays
            const checkboxFields = [
                { data: 'ictTypes', param: 'ictType' },
                { data: 'softwareTypes', param: 'softwareType' },
                { data: 'hardwareCategories', param: 'hardwareCategory' },
                { data: 'videoTypes', param: 'videoType' },
                { data: 'mediaRequirements', param: 'mediaRequirements' },
                { data: 'supportTypes', param: 'supportType' }
            ];

            checkboxFields.forEach(field => {
                if (formData[field.data] && formData[field.data].length > 0) {
                    formData[field.data].forEach(value => {
                        urlParams.append(field.param, value);
                    });
                }
            });

            // Add website URL
            if (formData.websiteURL) {
                urlParams.set('websiteURL', formData.websiteURL);
            }

            // Update URL without page reload
            const newURL = window.location.pathname + '?' + urlParams.toString();
            window.history.replaceState({}, '', newURL);
        }

        // --- "NONE OF THE ABOVE" HANDLING ---
        function setupNoneHandling() {
            const checkboxGroups = ['softwareType', 'hardwareCategory', 'videoType', 'supportType'];
            
            checkboxGroups.forEach(groupName => {
                const noneCheckbox = document.querySelector(`input[name="${groupName}"][value="none"]`);
                const otherCheckboxes = Array.from(document.querySelectorAll(`input[name="${groupName}"]:not([value="none"])`));
                
                if (noneCheckbox && otherCheckboxes.length > 0) {
                    // When "none" is checked, uncheck all others
                    noneCheckbox.addEventListener('change', function() {
                        if (this.checked) {
                            otherCheckboxes.forEach(cb => {
                                cb.checked = false;
                            });
                        }
                        updateURLFromForm();
                    });
                    
                    // When any other is checked, uncheck "none"
                    otherCheckboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', function() {
                            if (this.checked && noneCheckbox.checked) {
                                noneCheckbox.checked = false;
                            }
                            updateURLFromForm();
                        });
                    });
                }
            });
        }
        
        // --- DEFAULT VALUES SETUP ---
        function setDefaultValues() {
            // Set default project name if empty
            const projectNameInput = document.getElementById('projectName');
            if (!projectNameInput.value.trim()) {
                projectNameInput.value = 'Default Project Name';
            }

            // Set default procurement phase
            let procurementPhaseSelected = document.querySelector('input[name="procurementPhase"]:checked');
            if (!procurementPhaseSelected) {
                const defaultPhase = document.querySelector('input[name="procurementPhase"][value="tenderDevelopment"]');
                if (defaultPhase) defaultPhase.checked = true;
            }

            // Set default exemption
            let exemptionSelected = document.querySelector('input[name="exemption"]:checked');
            if (!exemptionSelected) {
                const defaultExemption = document.querySelector('input[name="exemption"][value="none"]');
                if (defaultExemption) defaultExemption.checked = true;
            }

            // Set default web content
            let webContentSelected = document.querySelector('input[name="webContent"]:checked');
            if (!webContentSelected) {
                const defaultWebContent = document.querySelector('input[name="webContent"][value="yes"]');
                if (defaultWebContent) {
                    defaultWebContent.checked = true;
                    defaultWebContent.dispatchEvent(new Event('change'));
                }
            }

            // Set default WCAG level if web content is selected
            setTimeout(() => {
                let wcagLevelSelected = document.querySelector('input[name="wcagLevel"]:checked');
                if (!wcagLevelSelected && document.querySelector('input[name="webContent"][value="yes"]')?.checked) {
                    const defaultWcagLevel = document.querySelector('input[name="wcagLevel"][value="AA"]');
                    if (defaultWcagLevel) defaultWcagLevel.checked = true;
                }
            }, 100);
        }

        // --- UPDATE URL FROM FORM ---
        function updateURLFromForm() {
            const formData = collectFormData();
            const params = new URLSearchParams();

            // Add project name
            if (formData.projectName) {
                params.set('projectName', formData.projectName);
            }

            // Add radio button values
            const radioGroups = ['procurementPhase', 'exemption', 'webContent', 'wcagLevel', 'publicWebsite', 'closedFunctionality', 'authoringCapability'];
            radioGroups.forEach(groupName => {
                if (formData[groupName]) {
                    params.set(groupName, formData[groupName]);
                }
            });

            // Add checkbox arrays
            const checkboxGroups = ['ictTypes', 'softwareTypes', 'hardwareCategories', 'videoTypes', 'mediaRequirements', 'supportTypes'];
            checkboxGroups.forEach(groupName => {
                if (formData[groupName] && formData[groupName].length > 0) {
                    formData[groupName].forEach(value => {
                        params.append(groupName.slice(0, -1), value); // Remove 's' suffix
                    });
                }
            });

            // Add website URL
            if (formData.websiteURL) {
                params.set('websiteURL', formData.websiteURL);
            }

            // Update URL without triggering page reload
            const newURL = `${window.location.pathname}${params.toString() ? '?' + params.toString() : ''}`;
            window.history.replaceState({}, '', newURL);
        }
        
        // --- LANGUAGE SWITCHER AND EVENT HANDLERS ---
        document.addEventListener('DOMContentLoaded', function() {
            renderForm();
            setDefaultValues(); // Set default form values
            populateFormFromURL(); // Load URL parameters after form is rendered
            setupNoneHandling(); // Setup "None of the above" logic
            
            document.getElementById('langSwitcher').addEventListener('change', function(e) {
                currentLang = e.target.value;
                renderForm();
                populateFormFromURL(); // Reapply URL parameters after language change
                setupNoneHandling(); // Re-setup "None of the above" logic
                // Optionally rerender output if present
                if (window.currentRequirements) {
                    displayRequirements(window.currentRequirements);
                }
            });

            // Add form change listeners to update URL parameters
            document.addEventListener('change', function(e) {
                if (e.target.matches('input, select, textarea')) {
                    setTimeout(updateURLFromForm, 100); // Small delay to ensure form data is updated
                }
            });
        });

            // --- URL PARAMETER HANDLING ---
        function populateFormFromURL() {
            const urlParams = new URLSearchParams(window.location.search);

            // Project Name
            if (urlParams.has('projectName')) {
                const projectNameInput = document.getElementById('projectName');
                if (projectNameInput) {
                    projectNameInput.value = urlParams.get('projectName');
                }
            }

            // Radio Buttons
            const radioGroups = ['procurementPhase', 'exemption', 'webContent', 'wcagLevel', 'publicWebsite', 'authoringCapability', 'closedFunctionality'];
            radioGroups.forEach(groupName => {
                if (urlParams.has(groupName)) {
                    const value = urlParams.get(groupName);
                    const radio = document.querySelector(`input[name="${groupName}"][value="${value}"]`);
                    if (radio) {
                        radio.checked = true;
                        radio.dispatchEvent(new Event('change'));
                    }
                }
            });

            // Checkboxes - handle multiple values
            const checkboxGroups = ['ictType', 'softwareType', 'hardwareCategory', 'videoType', 'mediaRequirements', 'supportType'];
            checkboxGroups.forEach(groupName => {
                // First, uncheck all in the group
                document.querySelectorAll(`input[name="${groupName}"]`).forEach(checkbox => {
                    checkbox.checked = false;
                });

                if (urlParams.has(groupName)) {
                    const values = urlParams.getAll(groupName);
                    values.forEach(value => {
                        const checkbox = document.querySelector(`input[name="${groupName}"][value="${value}"]`);
                        if (checkbox) {
                            checkbox.checked = true;
                            checkbox.dispatchEvent(new Event('change'));
                        }
                    });
                } else {
                    // If parameter is missing, check 'none' option by default if it exists
                    const noneCheckbox = document.querySelector(`input[name="${groupName}"][value="none"]`);
                    if (noneCheckbox) {
                        noneCheckbox.checked = true;
                        noneCheckbox.dispatchEvent(new Event('change'));
                    }
                }
            });

            // Website URL
            if (urlParams.has('websiteURL')) {
                const websiteURLInput = document.getElementById('websiteURL');
                if (websiteURLInput) {
                    websiteURLInput.value = urlParams.get('websiteURL');
                }
            }
        }

        function updateURLFromForm() {
            const formData = collectFormData();
            const urlParams = new URLSearchParams();

            // Add project name
            if (formData.projectName) {
                urlParams.set('projectName', formData.projectName);
            }

            // Add radio button values
            const radioFields = ['procurementPhase', 'exemption', 'webContent', 'wcagLevel', 'publicWebsite', 'authoringCapability', 'closedFunctionality'];
            radioFields.forEach(field => {
                if (formData[field]) {
                    urlParams.set(field, formData[field]);
                }
            });

            // Add checkbox arrays
            const checkboxFields = [
                { data: 'ictTypes', param: 'ictType' },
                { data: 'softwareTypes', param: 'softwareType' },
                { data: 'hardwareCategories', param: 'hardwareCategory' },
                { data: 'videoTypes', param: 'videoType' },
                { data: 'mediaRequirements', param: 'mediaRequirements' },
                { data: 'supportTypes', param: 'supportType' }
            ];

            checkboxFields.forEach(field => {
                if (formData[field.data] && formData[field.data].length > 0) {
                    formData[field.data].forEach(value => {
                        urlParams.append(field.param, value);
                    });
                }
            });

            // Add website URL
            if (formData.websiteURL) {
                urlParams.set('websiteURL', formData.websiteURL);
            }

            // Update URL without page reload
            const newURL = window.location.pathname + '?' + urlParams.toString();
            window.history.replaceState({}, '', newURL);
        }

        // --- "NONE OF THE ABOVE" HANDLING ---
        function setupNoneHandling() {
            const checkboxGroups = ['softwareType', 'hardwareCategory', 'videoType', 'supportType'];
            
            checkboxGroups.forEach(groupName => {
                const noneCheckbox = document.querySelector(`input[name="${groupName}"][value="none"]`);
                const otherCheckboxes = Array.from(document.querySelectorAll(`input[name="${groupName}"]:not([value="none"])`));
                
                if (noneCheckbox && otherCheckboxes.length > 0) {
                    // When "none" is checked, uncheck all others
                    noneCheckbox.addEventListener('change', function() {
                        if (this.checked) {
                            otherCheckboxes.forEach(cb => {
                                cb.checked = false;
                            });
                        }
                        updateURLFromForm();
                    });
                    
                    // When any other is checked, uncheck "none"
                    otherCheckboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', function() {
                            if (this.checked && noneCheckbox.checked) {
                                noneCheckbox.checked = false;
                            }
                            updateURLFromForm();
                        });
                    });
                }
            });
        }
        
        // --- DISPLAY REQUIREMENTS ---
        function displayRequirements(requirements) {
            const t = translations[currentLang];
            const outputDiv = document.getElementById('output');
            
            // Get procurement phase for phase-specific guidance
            const procurementPhase = requirements.data.procurementPhase;
            let phaseGuidance = '';
            
            if (procurementPhase === 'projectPlanning') {
                phaseGuidance = currentLang === 'en' ? `
                    <h4>Requirements Planning Phase Guidance</h4>
                    <p>Use these requirements to:</p>
                    <ul>
                        <li>Establish accessibility budget and timeline expectations</li>
                        <li>Identify required team expertise and roles</li>
                        <li>Plan for ongoing accessibility testing and validation</li>
                        <li>Understand compliance scope for your ICT procurement</li>
                    </ul>` : `
                    <h4>Conseils pour la phase de planification des exigences</h4>
                    <p>Utilisez ces exigences pour :</p>
                    <ul>
                        <li>√âtablir les attentes budg√©taires et calendaires d'accessibilit√©</li>
                        <li>Identifier l'expertise et les r√¥les requis de l'√©quipe</li>
                        <li>Planifier les tests et validations d'accessibilit√© en cours</li>
                        <li>Comprendre la port√©e de conformit√© pour votre approvisionnement TIC</li>
                    </ul>`;
            } else if (procurementPhase === 'marketResearch') {
                phaseGuidance = currentLang === 'en' ? `
                    <h4>Market Research Phase Guidance</h4>
                    <p>Include these criteria in RFI/market research to:</p>
                    <ul>
                        <li>Evaluate vendor accessibility capabilities and experience</li>
                        <li>Request current Accessibility Conformance Reports (ACRs)</li>
                        <li>Assess marketplace availability of accessible solutions</li>
                        <li>Identify potential accessibility implementation challenges</li>
                    </ul>` : `
                    <h4>Conseils pour la phase d'√©tude de march√©</h4>
                    <p>Incluez ces crit√®res dans la DDI/√©tude de march√© pour :</p>
                    <ul>
                        <li>√âvaluer les capacit√©s et l'exp√©rience d'accessibilit√© des fournisseurs</li>
                        <li>Demander les rapports de conformit√© d'accessibilit√© (RCA) actuels</li>
                        <li>√âvaluer la disponibilit√© sur le march√© de solutions accessibles</li>
                        <li>Identifier les d√©fis potentiels de mise en ≈ìuvre de l'accessibilit√©</li>
                    </ul>`;
            } else {
                phaseGuidance = currentLang === 'en' ? `
                    <h4>Tender Development Guidance</h4>
                    <p>Copy the requirements below into your Statement of Work (SOW), Performance Work Statement (PWS), or Statement of Objectives (SOO).</p>
                    <p><strong>Note:</strong> These requirements are designed to be vendor-agnostic and establish clear performance expectations. Customize based on your organization's specific needs.</p>` : `
                    <h4>Conseils pour l'√©laboration de l'appel d'offres</h4>
                    <p>Copiez les exigences ci-dessous dans votre √©nonc√© de travail (√âT), √©nonc√© de travail de performance (√âTP), ou √©nonc√© d'objectifs (√âO).</p>
                    <p><strong>Note :</strong> Ces exigences sont con√ßues pour √™tre neutres vis-√†-vis des fournisseurs et √©tablir des attentes de performance claires. Personnalisez selon les besoins sp√©cifiques de votre organisation.</p>`;
            }
            
            // Create output with guidance and editable requirements
            let outputHTML = '';
            
            // Procurement Officer Guidance Section
            outputHTML += `<div style="background-color: #f8f9fa; border: 2px solid #6c757d; border-radius: 8px; padding: 20px; margin-bottom: 30px;">`;
            outputHTML += `<h2 style="color: #495057; margin-top: 0;">üìã ${currentLang === 'en' ? 'For Procurement Officers - Review & Guidance' : 'Pour les agents d\'approvisionnement - Examen et conseils'}</h2>`;
            outputHTML += `<p style="background-color: #d1ecf1; padding: 10px; border-radius: 5px; margin-bottom: 15px;">`;
            outputHTML += `<strong>${currentLang === 'en' ? 'Project' : 'Projet'}:</strong> ${requirements.data.projectName} | `;
            outputHTML += `<strong>${currentLang === 'en' ? 'Language' : 'Langue'}:</strong> ${t.langName}`;
            outputHTML += `</p>`;
            
            outputHTML += `<div style="background-color: #d4edda; padding: 15px; border-radius: 5px; margin-bottom: 15px;">`;
            outputHTML += `<h4>${currentLang === 'en' ? 'Why is this important?' : 'Pourquoi est-ce important ?'}</h4>`;
            outputHTML += `<p>${currentLang === 'en' ? 
                'EN 301 549 compliance ensures your procurement meets international accessibility standards, reduces legal risks, and creates inclusive ICT solutions that serve all users effectively.' :
                'La conformit√© EN 301 549 garantit que votre approvisionnement respecte les normes internationales d\'accessibilit√©, r√©duit les risques juridiques et cr√©e des solutions TIC inclusives qui servent efficacement tous les utilisateurs.'}</p>`;
            outputHTML += `</div>`;
            
            outputHTML += phaseGuidance;
            
            // Government oversight responsibilities
            outputHTML += `<div style="background-color: #fff3cd; padding: 15px; border-radius: 5px; margin-top: 15px;">`;
            outputHTML += `<h4>${currentLang === 'en' ? 'Government Oversight Responsibilities' : 'Responsabilit√©s de surveillance gouvernementale'}</h4>`;
            outputHTML += `<p>${currentLang === 'en' ? 'As the procurement officer, you must ensure ongoing compliance by:' : 'En tant qu\'agent d\'approvisionnement, vous devez assurer la conformit√© continue en :'}</p>`;
            outputHTML += `<ul>`;
            if (currentLang === 'en') {
                outputHTML += `<li>Regularly reviewing and validating ACR submissions for accuracy and completeness</li>`;
                outputHTML += `<li>Conducting periodic accessibility audits using both automated tools and expert evaluation</li>`;
                outputHTML += `<li>Monitoring contractor performance against accessibility milestones and deliverables</li>`;
                outputHTML += `<li>Ensuring timely remediation of identified accessibility issues</li>`;
                outputHTML += `<li>Documenting accessibility compliance status in all project reports and reviews</li>`;
                outputHTML += `<li>Escalating persistent accessibility non-compliance through appropriate contract management channels</li>`;
            } else {
                outputHTML += `<li>Examiner et valider r√©guli√®rement les soumissions de RCA pour leur exactitude et leur exhaustivit√©</li>`;
                outputHTML += `<li>Effectuer des audits d'accessibilit√© p√©riodiques en utilisant des outils automatis√©s et une √©valuation d'experts</li>`;
                outputHTML += `<li>Surveiller la performance des contractants par rapport aux jalons et livrables d'accessibilit√©</li>`;
                outputHTML += `<li>Assurer la correction rapide des probl√®mes d'accessibilit√© identifi√©s</li>`;
                outputHTML += `<li>Documenter le statut de conformit√© d'accessibilit√© dans tous les rapports et examens de projet</li>`;
                outputHTML += `<li>Escalader la non-conformit√© persistante d'accessibilit√© par les canaux appropri√©s de gestion de contrat</li>`;
            }
            outputHTML += `</ul>`;
            outputHTML += `</div>`;
            
            outputHTML += `<p class="important-note" style="background-color: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px; margin-top: 15px; font-weight: bold;">`;
            outputHTML += `${currentLang === 'en' ? 
                '‚ö†Ô∏è Important: Do not copy these instructions into the solicitation - only copy the requirements text below.' :
                '‚ö†Ô∏è Important : Ne copiez pas ces instructions dans l\'appel d\'offres - copiez uniquement le texte des exigences ci-dessous.'}`;
            outputHTML += `</p>`;
            outputHTML += `</div>`;
            
            // Editable Requirements Section
            outputHTML += `<div style="background-color: #e7f3ff; border: 3px solid #0056b3; border-radius: 8px; padding: 20px;">`;
            outputHTML += `<h2 style="color: #0056b3; margin-top: 0;">üìÑ ${currentLang === 'en' ? 
                'Requirements for Copy-Paste into Procurement Documents' : 
                'Exigences √† copier-coller dans les documents d\'approvisionnement'}</h2>`;
            
            outputHTML += `<label for="outputText">${currentLang === 'en' ? 
                'Review the requirements below. You can edit the text directly in the textarea.' :
                'Examinez les exigences ci-dessous. Vous pouvez modifier le texte directement dans la zone de texte.'}</label>`;
            outputHTML += `<textarea id="outputText" aria-describedby="output-instructions" style="width: 100%; height: 400px; padding: 10px; font-family: 'Courier New', monospace; font-size: 0.9em; border: 1px solid #ccc; border-radius: 5px; resize: vertical; margin-top: 10px;">${requirements.text}</textarea>`;
            
            outputHTML += `<div id="output-instructions" style="margin-top: 10px; font-size: 0.9em; color: #666;">`;
            outputHTML += `<strong>${currentLang === 'en' ? 'Note:' : 'Note :'}</strong> ${currentLang === 'en' ? 
                '"Update Requirements from Form" will regenerate the requirements based on your current form selections above. Any manual edits to the text will be lost.' :
                '"Mettre √† jour les exigences du formulaire" r√©g√©n√©rera les exigences bas√©es sur vos s√©lections actuelles du formulaire ci-dessus. Toutes les modifications manuelles du texte seront perdues.'}`;
            outputHTML += `</div>`;
            
            // Action buttons
            outputHTML += `<div style="margin-top: 20px; text-align: center;">`;
            outputHTML += `<button type="button" id="copyRequirements" style="background-color: #28a745; margin-right: 10px;">üìã ${currentLang === 'en' ? 'Copy Text' : 'Copier le texte'}</button>`;
            outputHTML += `<button type="button" id="copyForWord" style="background-color: #0078d4; color: white; margin-right: 10px;">üìù ${currentLang === 'en' ? 'Copy for Word (HTML)' : 'Copier pour Word (HTML)'}</button>`;
            outputHTML += `<button type="button" id="previewHTML" style="background-color: #6f42c1; color: white; margin-right: 10px;">üëÅÔ∏è ${currentLang === 'en' ? 'Preview HTML' : 'Aper√ßu HTML'}</button>`;
            outputHTML += `<button type="button" id="downloadRequirements" style="background-color: #17a2b8; margin-right: 10px;">üíæ ${currentLang === 'en' ? 'Download as Text' : 'T√©l√©charger en tant que texte'}</button>`;
            outputHTML += `<button type="button" id="downloadWord" style="background-color: #d63384; color: white; margin-right: 10px;">üìÑ ${currentLang === 'en' ? 'Download as Word' : 'T√©l√©charger en tant que Word'}</button>`;
            outputHTML += `<button type="button" id="regenerateOutput" style="background-color: #ffc107; color: #000;" title="${currentLang === 'en' ? 
                'Re-run the form logic if you\'ve changed any selections above' : 
                'Relancer la logique du formulaire si vous avez modifi√© des s√©lections ci-dessus'}">üîÑ ${currentLang === 'en' ? 'Update Requirements from Form' : 'Mettre √† jour les exigences du formulaire'}</button>`;
            outputHTML += `</div>`;
            outputHTML += `<div id="copyStatus" style="margin-top: 10px; color: green; display: none; text-align: center;" role="status" aria-live="polite">${currentLang === 'en' ? 'Copied to clipboard!' : 'Copi√© dans le presse-papiers !'}</div>`;
            outputHTML += `</div>`;
            
            outputDiv.innerHTML = outputHTML;
            
            // Add event listeners for buttons
            document.getElementById('copyRequirements').addEventListener('click', function() {
                const textArea = document.getElementById('outputText');
                textArea.select();
                document.execCommand('copy');
                
                const copyStatus = document.getElementById('copyStatus');
                copyStatus.style.display = 'block';
                setTimeout(() => {
                    copyStatus.style.display = 'none';
                }, 2000);
            });

            document.getElementById('copyForWord').addEventListener('click', function() {
                const textArea = document.getElementById('outputText');
                const text = textArea.value;
                
                // Convert text to HTML format suitable for Word/Google Docs
                let htmlContent = text
                    // Handle headers (lines ending with all caps followed by dashes/equals)
                    .replace(/^([A-Z\s\d]+)\n([=\-]+)\n/gm, '<h2>$1</h2>')
                    // Handle sub-headers (lines ending with dashes but not all caps)
                    .replace(/^([A-Za-z\s\d:]+)\n([-]+)\n/gm, '<h3>$1</h3>')
                    // Handle bullet points (lines starting with ‚Ä¢)
                    .replace(/^‚Ä¢ (.+)$/gm, '<li>$1</li>')
                    // Handle bold text (**text**)
                    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                    // Handle paragraphs (double newlines)
                    .replace(/\n\n/g, '</p><p>')
                    // Handle single newlines that aren't part of lists
                    .replace(/\n(?!<)/g, '<br>')
                    // Wrap in paragraph tags
                    .replace(/^/, '<p>')
                    .replace(/$/, '</p>');
                
                // Fix list items to be properly wrapped in <ul> tags
                htmlContent = htmlContent.replace(/(<li>.*?<\/li>)/g, function(match) {
                    // If this li is not already in a ul, wrap it
                    return match;
                });
                
                // Group consecutive list items in <ul> tags
                htmlContent = htmlContent.replace(/(<li>.*?<\/li>)(\s*<br>\s*<li>.*?<\/li>)*/g, function(match) {
                    const items = match.replace(/<br>\s*/g, '').trim();
                    return '<ul>' + items + '</ul>';
                });
                
                // Clean up empty paragraphs and fix structure
                htmlContent = htmlContent
                    .replace(/<p><\/p>/g, '')
                    .replace(/<p><h([1-6])>/g, '<h$1>')
                    .replace(/<\/h([1-6])><\/p>/g, '</h$1>')
                    .replace(/<p><ul>/g, '<ul>')
                    .replace(/<\/ul><\/p>/g, '</ul>')
                    .replace(/(<h[1-6]>.*?<\/h[1-6]>)\s*<br>/g, '$1');
                
                // Apply styling
                const styledContent = `
                    <div style="font-family: Arial, sans-serif; line-height: 1.6; color: #000;">
                        ${htmlContent}
                    </div>
                `;
                
                // Use the Clipboard API with HTML MIME type
                const clipboardItem = new ClipboardItem({
                    'text/html': new Blob([styledContent], { type: 'text/html' }),
                    'text/plain': new Blob([text], { type: 'text/plain' })
                });
                
                navigator.clipboard.write([clipboardItem]).then(() => {
                    const copyStatus = document.getElementById('copyStatus');
                    copyStatus.innerHTML = currentLang === 'en' ? 
                        'Formatted content copied! Paste into Word/Google Docs for formatted text.' : 
                        'Contenu format√© copi√© ! Collez dans Word/Google Docs pour du texte format√©.';
                    copyStatus.style.display = 'block';
                    setTimeout(() => {
                        copyStatus.style.display = 'none';
                    }, 3000);
                }).catch((err) => {
                    // Fallback for browsers that don't support ClipboardItem
                    console.warn('ClipboardItem not supported, falling back to selection method');
                    
                    // Create a temporary element with the HTML content
                    const tempElement = document.createElement('div');
                    tempElement.innerHTML = styledContent;
                    tempElement.style.position = 'absolute';
                    tempElement.style.left = '-9999px';
                    document.body.appendChild(tempElement);
                    
                    // Select the content
                    const range = document.createRange();
                    range.selectNode(tempElement);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Copy the selection (this preserves HTML formatting)
                    document.execCommand('copy');
                    
                    // Clean up
                    selection.removeAllRanges();
                    document.body.removeChild(tempElement);
                    
                    const copyStatus = document.getElementById('copyStatus');
                    copyStatus.innerHTML = currentLang === 'en' ? 
                        'Formatted content copied! Paste into Word/Google Docs for formatted text.' : 
                        'Contenu format√© copi√© ! Collez dans Word/Google Docs pour du texte format√©.';
                    copyStatus.style.display = 'block';
                    setTimeout(() => {
                        copyStatus.style.display = 'none';
                    }, 3000);
                });
            });

            document.getElementById('previewHTML').addEventListener('click', function() {
                const textArea = document.getElementById('outputText');
                const text = textArea.value;
                
                // Convert text to HTML
                const htmlContent = text
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/\n/g, '<br>')
                    .replace(/^/, '<p>')
                    .replace(/$/, '</p>');
                
                const fullHTML = `
                    <html>
                    <head>
                        <meta charset="utf-8">
                        <title>EN 301 549 Requirements Preview</title>
                        <style>
                            body { font-family: Arial, sans-serif; line-height: 1.6; margin: 40px; background: white; }
                            h1, h2, h3 { color: #0056b3; }
                            p { margin-bottom: 12px; }
                        </style>
                    </head>
                    <body>
                        ${htmlContent}
                    </body>
                    </html>
                `;
                
                // Open in new window
                const previewWindow = window.open('', '_blank');
                previewWindow.document.write(fullHTML);
                previewWindow.document.close();
            });
            
            document.getElementById('downloadRequirements').addEventListener('click', function() {
                const textArea = document.getElementById('outputText');
                const blob = new Blob([textArea.value], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const projectName = requirements.data.projectName || 'Project';
                const sanitizedProjectName = projectName.replace(/[^a-zA-Z0-9\-_]/g, '_');
                a.href = url;
                a.download = `EN301549-Requirements-${sanitizedProjectName}-${new Date().toISOString().split('T')[0]}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            });

            document.getElementById('downloadWord').addEventListener('click', function() {
                const textArea = document.getElementById('outputText');
                const text = textArea.value;
                
                // Convert text to HTML format
                const htmlContent = text
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/\n/g, '<br>')
                    .replace(/^/, '<p>')
                    .replace(/$/, '</p>');
                
                const fullHTML = `
                    <html xmlns:o="urn:schemas-microsoft-com:office:office"
                          xmlns:w="urn:schemas-microsoft-com:office:word"
                          xmlns="http://www.w3.org/TR/REC-html40">
                    <head>
                        <meta charset="utf-8">
                        <title>EN 301 549 Requirements</title>
                        <!--[if gte mso 9]>
                        <xml>
                            <w:WordDocument>
                                <w:View>Print</w:View>
                                <w:Zoom>90</w:Zoom>
                                <w:DoNotOptimizeForBrowser/>
                            </w:WordDocument>
                        </xml>
                        <![endif]-->
                        <style>
                            body { font-family: Arial, sans-serif; line-height: 1.6; margin: 40px; }
                            h1, h2, h3 { color: #0056b3; }
                            p { margin-bottom: 12px; }
                        </style>
                    </head>
                    <body>
                        ${htmlContent}
                    </body>
                    </html>
                `;
                
                const blob = new Blob([fullHTML], { type: 'application/msword' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const projectName = requirements.data.projectName || 'Project';
                const sanitizedProjectName = projectName.replace(/[^a-zA-Z0-9\-_]/g, '_');
                a.href = url;
                a.download = `EN301549-Requirements-${sanitizedProjectName}-${new Date().toISOString().split('T')[0]}.doc`;
                a.click();
                URL.revokeObjectURL(url);
            });
            
            document.getElementById('regenerateOutput').addEventListener('click', function() {
                // Trigger form submission again to regenerate with current form values
                document.getElementById('procurementForm').dispatchEvent(new Event('submit'));
            });
            
            // Store for potential reuse
            window.currentRequirements = requirements;
        }
        
        // --- COPY AND DOWNLOAD FUNCTIONS ---
        // --- FORM SUBMISSION AND VALIDATION ---
        function handleFormSubmission(e) {
            e.preventDefault();
            const t = translations[currentLang];
            
            let hasError = false;
            let errorMessages = [];
            
            // Clear previous error displays
            document.querySelectorAll('.error-message').forEach(el => el.style.display = 'none');
            
            // Validate Project Name
            const projectNameInput = document.getElementById('projectName');
            if (!projectNameInput.value.trim()) {
                document.getElementById('projectNameError').style.display = 'block';
                projectNameInput.style.borderColor = 'red';
                hasError = true;
                errorMessages.push(t.requiredField);
            } else {
                projectNameInput.style.borderColor = '';
            }
            
            // Validate required radio/checkbox groups
            const requiredGroups = [
                { name: 'procurementPhase', label: t.procurementPhase },
                { name: 'ictType', label: t.ictType },
                { name: 'exemption', label: t.exemption },
                { name: 'webContent', label: t.webContent },
                { name: 'softwareType', label: t.softwareType },
                { name: 'hardwareCategory', label: t.hardwareCategory },
                { name: 'videoType', label: t.videoType },
                { name: 'supportType', label: t.supportType }
            ];
            
            requiredGroups.forEach(group => {
                if (!document.querySelector(`input[name="${group.name}"]:checked`)) {
                    hasError = true;
                    errorMessages.push(`${group.label} is required.`);
                }
            });
            
            // Validate conditional fields
            const webContentValue = document.querySelector('input[name="webContent"]:checked')?.value;
            if (webContentValue === 'yes') {
                if (!document.querySelector('input[name="wcagLevel"]:checked')) {
                    hasError = true;
                    errorMessages.push(`${t.wcagLevel} is required when web content is selected.`);
                }
                if (!document.querySelector('input[name="publicWebsite"]:checked')) {
                    hasError = true;
                    errorMessages.push(`${t.publicWebsite} is required when web content is selected.`);
                }
            }
            
            // Show error messages if any
            if (hasError) {
                showErrorMessages(errorMessages, t.missingFields);
                return;
            }
            
            // If validation passes, generate requirements
            generateRequirements();
        }
        
        function showErrorMessages(messages, headerText) {
            let errorDiv = document.getElementById('formErrorMessages');
            if (!errorDiv) {
                errorDiv = document.createElement('div');
                errorDiv.id = 'formErrorMessages';
                errorDiv.style.cssText = 'color: red; margin: 10px 0; padding: 10px; border: 1px solid red; background-color: #ffe6e6; border-radius: 5px;';
                errorDiv.setAttribute('role', 'alert');
                document.getElementById('formSection').insertBefore(errorDiv, document.getElementById('formSection').firstChild);
            }
            
            errorDiv.innerHTML = `<strong>${headerText}</strong><ul>${messages.map(msg => `<li>${msg}</li>`).join('')}</ul>`;
            errorDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // --- COLLECT FORM DATA ---
        function collectFormData() {
            const data = {};
            
            // Get project name
            data.projectName = document.getElementById('projectName')?.value || '';
            
            // Get radio button values
            data.procurementPhase = document.querySelector('input[name="procurementPhase"]:checked')?.value || '';
            data.exemption = document.querySelector('input[name="exemption"]:checked')?.value || '';
            data.webContent = document.querySelector('input[name="webContent"]:checked')?.value || '';
            data.wcagLevel = document.querySelector('input[name="wcagLevel"]:checked')?.value || '';
            data.publicWebsite = document.querySelector('input[name="publicWebsite"]:checked')?.value || '';
            data.closedFunctionality = document.querySelector('input[name="closedFunctionality"]:checked')?.value || '';
            data.authoringCapability = document.querySelector('input[name="authoringCapability"]:checked')?.value || '';
            
            // Get checkbox arrays
            data.ictTypes = Array.from(document.querySelectorAll('input[name="ictType"]:checked')).map(cb => cb.value);
            data.softwareTypes = Array.from(document.querySelectorAll('input[name="softwareType"]:checked')).map(cb => cb.value);
            data.hardwareCategories = Array.from(document.querySelectorAll('input[name="hardwareCategory"]:checked')).map(cb => cb.value);
            data.videoTypes = Array.from(document.querySelectorAll('input[name="videoType"]:checked')).map(cb => cb.value);
            data.mediaRequirements = Array.from(document.querySelectorAll('input[name="mediaRequirements"]:checked')).map(cb => cb.value);
            data.supportTypes = Array.from(document.querySelectorAll('input[name="supportType"]:checked')).map(cb => cb.value);
            
            // Get website URL
            data.websiteURL = document.getElementById('websiteURL')?.value || '';
            
            return data;
        }
        
        // --- REQUIREMENTS GENERATION ---
        function generateRequirements() {
            const formData = collectFormData();
            const t = translations[currentLang];
            
            // Clear previous error messages
            const errorDiv = document.getElementById('formErrorMessages');
            if (errorDiv) errorDiv.innerHTML = '';
            
            // Generate comprehensive requirements text in both languages
            let requirementsText = '';
            
            if (currentLang === 'en') {
                requirementsText += `EN 301 549 ACCESSIBILITY REQUIREMENTS\n`;
                requirementsText += `========================================\n\n`;
                requirementsText += `Project: ${formData.projectName}\n`;
                requirementsText += `Generated: ${new Date().toLocaleDateString()}\n\n`;
                
                requirementsText += `CORE ACCESSIBILITY COMPLIANCE\n`;
                requirementsText += `-----------------------------\n`;
                requirementsText += `All ICT deliverables under this procurement must conform to:\n`;
                requirementsText += `‚Ä¢ EN 301 549 v3.2.1 (2021) "Accessibility requirements for ICT products and services"\n`;
                requirementsText += `‚Ä¢ WCAG 2.1 Level AA as referenced in EN 301 549\n`;
                requirementsText += `‚Ä¢ Applicable chapters of EN 301 549 based on ICT type and usage context\n\n`;
                
                if (formData.webContent === 'yes') {
                    requirementsText += `WEB CONTENT ACCESSIBILITY REQUIREMENTS\n`;
                    requirementsText += `--------------------------------------\n`;
                    requirementsText += `‚Ä¢ Conformance: WCAG 2.1 Level ${formData.wcagLevel || 'AA'}\n`;
                    requirementsText += `‚Ä¢ Applicable EN 301 549 Chapters: 9 (Web), 10 (Non-web documents)\n`;
                    requirementsText += `‚Ä¢ Public accessibility: ${formData.publicWebsite === 'yes' ? 'Yes - Enhanced public requirements apply' : 'Internal use - Standard requirements apply'}\n`;
                    if (formData.websiteURL) {
                        requirementsText += `‚Ä¢ Target website: ${formData.websiteURL}\n`;
                    }
                    requirementsText += `‚Ä¢ Required deliverables: Accessibility Conformance Report (ACR), VPAT documentation\n\n`;
                }
                
                if (formData.ictTypes.length > 0) {
                    requirementsText += `ICT TYPE-SPECIFIC REQUIREMENTS\n`;
                    requirementsText += `------------------------------\n`;
                    formData.ictTypes.forEach(type => {
                        const label = t.ictTypes[type] || type;
                        requirementsText += `‚Ä¢ ${label}: EN 301 549 applicable chapters per ICT type\n`;
                    });
                    requirementsText += `\n`;
                }
                
                if (formData.softwareTypes.length > 0) {
                    requirementsText += `SOFTWARE APPLICATION REQUIREMENTS\n`;
                    requirementsText += `---------------------------------\n`;
                    requirementsText += `‚Ä¢ Applicable EN 301 549 Chapters: 11 (Software)\n`;
                    formData.softwareTypes.forEach(type => {
                        const label = t.softwareTypes[type] || type;
                        requirementsText += `‚Ä¢ ${label}: Platform-specific accessibility APIs required\n`;
                    });
                    if (formData.authoringCapability) {
                        const capability = t.authoringCapabilities[formData.authoringCapability] || formData.authoringCapability;
                        requirementsText += `‚Ä¢ Authoring tool capability: ${capability}\n`;
                        requirementsText += `‚Ä¢ Applicable EN 301 549 Chapter: 11.8 (Authoring tools)\n`;
                    }
                    requirementsText += `\n`;
                }
                
                if (formData.hardwareCategories.length > 0) {
                    requirementsText += `HARDWARE ACCESSIBILITY REQUIREMENTS\n`;
                    requirementsText += `-----------------------------------\n`;
                    requirementsText += `‚Ä¢ Applicable EN 301 549 Chapters: 8 (Hardware)\n`;
                    formData.hardwareCategories.forEach(cat => {
                        const label = t.hardwareCategories[cat] || cat;
                        requirementsText += `‚Ä¢ ${label}: Physical accessibility and interface requirements\n`;
                    });
                    if (formData.closedFunctionality) {
                        requirementsText += `‚Ä¢ Closed functionality: ${formData.closedFunctionality === 'yes' ? 'Yes - Chapter 8 closed functionality requirements apply' : 'No - Standard hardware requirements apply'}\n`;
                    }
                    requirementsText += `\n`;
                }
                
                if (formData.videoTypes.length > 0) {
                    requirementsText += `MEDIA AND TELECOMMUNICATIONS REQUIREMENTS\n`;
                    requirementsText += `-----------------------------------------\n`;
                    requirementsText += `‚Ä¢ Applicable EN 301 549 Chapters: 6 (ICT with two-way voice), 7 (ICT with video)\n`;
                    formData.videoTypes.forEach(type => {
                        const label = t.videoTypes[type] || type;
                        requirementsText += `‚Ä¢ ${label}: Real-time text, captions, and communication accessibility\n`;
                    });
                    if (formData.mediaRequirements.length > 0) {
                        requirementsText += `‚Ä¢ Required accessibility features:\n`;
                        formData.mediaRequirements.forEach(req => {
                            const label = t.mediaRequirements[req] || req;
                            requirementsText += `  - ${label}\n`;
                        });
                    }
                    requirementsText += `\n`;
                }
                
                if (formData.supportTypes.length > 0) {
                    requirementsText += `SUPPORT AND DOCUMENTATION REQUIREMENTS\n`;
                    requirementsText += `--------------------------------------\n`;
                    requirementsText += `‚Ä¢ Applicable EN 301 549 Chapters: 12 (Documentation and support)\n`;
                    formData.supportTypes.forEach(type => {
                        const label = t.supportTypes[type] || type;
                        requirementsText += `‚Ä¢ ${label}: Accessible format and delivery required\n`;
                    });
                    requirementsText += `\n`;
                }
                
                requirementsText += `PROCUREMENT AND VALIDATION REQUIREMENTS\n`;
                requirementsText += `---------------------------------------\n`;
                requirementsText += `‚Ä¢ Vendor must provide current Accessibility Conformance Report (ACR)\n`;
                requirementsText += `‚Ä¢ ACR must be in OpenACR format (both HTML and YAML versions)\n`;
                requirementsText += `‚Ä¢ Independent accessibility testing may be required\n`;
                requirementsText += `‚Ä¢ Ongoing compliance monitoring throughout contract period\n`;
                requirementsText += `‚Ä¢ Remediation plan required for any identified non-conformance\n\n`;
                
                requirementsText += `EXEMPTION STATUS\n`;
                requirementsText += `----------------\n`;
                const exemptionLabel = t.exemptions[formData.exemption] || formData.exemption || 'Not specified';
                requirementsText += `Exemption: ${exemptionLabel}\n\n`;
                
                requirementsText += `PROCUREMENT PHASE\n`;
                requirementsText += `-----------------\n`;
                const phaseLabel = t.procurementPhases[formData.procurementPhase] || formData.procurementPhase || 'Not specified';
                requirementsText += `Current phase: ${phaseLabel}\n\n`;
                
                requirementsText += `REFERENCE STANDARDS\n`;
                requirementsText += `-------------------\n`;
                requirementsText += `‚Ä¢ EN 301 549 v3.2.1 (2021): https://www.etsi.org/deliver/etsi_en/301500_301599/301549/03.02.01_60/en_301549v030201p.pdf\n`;
                requirementsText += `‚Ä¢ WCAG 2.1: https://www.w3.org/TR/WCAG21/\n`;
                requirementsText += `‚Ä¢ Additional guidance: https://accessible.canada.ca/\n`;
                
            } else {
                requirementsText += `EXIGENCES D'ACCESSIBILIT√â EN 301 549\n`;
                requirementsText += `=====================================\n\n`;
                requirementsText += `Projet : ${formData.projectName}\n`;
                requirementsText += `G√©n√©r√© : ${new Date().toLocaleDateString()}\n\n`;
                
                requirementsText += `CONFORMIT√â D'ACCESSIBILIT√â DE BASE\n`;
                requirementsText += `----------------------------------\n`;
                requirementsText += `Tous les livrables TIC de cet approvisionnement doivent se conformer √† :\n`;
                requirementsText += `‚Ä¢ EN 301 549 v3.2.1 (2021) "Exigences d'accessibilit√© pour les produits et services TIC"\n`;
                requirementsText += `‚Ä¢ WCAG 2.1 Niveau AA tel que r√©f√©renc√© dans EN 301 549\n`;
                requirementsText += `‚Ä¢ Chapitres applicables d'EN 301 549 bas√©s sur le type TIC et le contexte d'usage\n\n`;
                
                if (formData.webContent === 'yes') {
                    requirementsText += `EXIGENCES D'ACCESSIBILIT√â DU CONTENU WEB\n`;
                    requirementsText += `----------------------------------------\n`;
                    requirementsText += `‚Ä¢ Conformit√© : WCAG 2.1 Niveau ${formData.wcagLevel || 'AA'}\n`;
                    requirementsText += `‚Ä¢ Chapitres EN 301 549 applicables : 9 (Web), 10 (Documents non-web)\n`;
                    requirementsText += `‚Ä¢ Accessibilit√© publique : ${formData.publicWebsite === 'yes' ? 'Oui - Exigences publiques renforc√©es s\'appliquent' : 'Usage interne - Exigences standard s\'appliquent'}\n`;
                    if (formData.websiteURL) {
                        requirementsText += `‚Ä¢ Site web cible : ${formData.websiteURL}\n`;
                    }
                    requirementsText += `‚Ä¢ Livrables requis : Rapport de conformit√© d'accessibilit√© (RCA), documentation VPAT\n\n`;
                }
                
                if (formData.ictTypes.length > 0) {
                    requirementsText += `EXIGENCES SP√âCIFIQUES AU TYPE TIC\n`;
                    requirementsText += `---------------------------------\n`;
                    formData.ictTypes.forEach(type => {
                        const label = t.ictTypes[type] || type;
                        requirementsText += `‚Ä¢ ${label} : Chapitres EN 301 549 applicables par type TIC\n`;
                    });
                    requirementsText += `\n`;
                }
                
                if (formData.softwareTypes.length > 0) {
                    requirementsText += `EXIGENCES DES APPLICATIONS LOGICIELLES\n`;
                    requirementsText += `--------------------------------------\n`;
                    requirementsText += `‚Ä¢ Chapitres EN 301 549 applicables : 11 (Logiciel)\n`;
                    formData.softwareTypes.forEach(type => {
                        const label = t.softwareTypes[type] || type;
                        requirementsText += `‚Ä¢ ${label} : APIs d'accessibilit√© sp√©cifiques √† la plateforme requises\n`;
                    });
                    if (formData.authoringCapability) {
                        const capability = t.authoringCapabilities[formData.authoringCapability] || formData.authoringCapability;
                        requirementsText += `‚Ä¢ Capacit√© d'outil d'√©dition : ${capability}\n`;
                        requirementsText += `‚Ä¢ Chapitre EN 301 549 applicable : 11.8 (Outils d'√©dition)\n`;
                    }
                    requirementsText += `\n`;
                }
                
                if (formData.hardwareCategories.length > 0) {
                    requirementsText += `EXIGENCES D'ACCESSIBILIT√â MAT√âRIELLE\n`;
                    requirementsText += `------------------------------------\n`;
                    requirementsText += `‚Ä¢ Chapitres EN 301 549 applicables : 8 (Mat√©riel)\n`;
                    formData.hardwareCategories.forEach(cat => {
                        const label = t.hardwareCategories[cat] || cat;
                        requirementsText += `‚Ä¢ ${label} : Exigences d'accessibilit√© physique et d'interface\n`;
                    });
                    if (formData.closedFunctionality) {
                        requirementsText += `‚Ä¢ Fonctionnalit√© ferm√©e : ${formData.closedFunctionality === 'yes' ? 'Oui - Exigences de fonctionnalit√© ferm√©e du Chapitre 8 s\'appliquent' : 'Non - Exigences mat√©rielles standard s\'appliquent'}\n`;
                    }
                    requirementsText += `\n`;
                }
                
                if (formData.videoTypes.length > 0) {
                    requirementsText += `EXIGENCES M√âDIAS ET T√âL√âCOMMUNICATIONS\n`;
                    requirementsText += `-------------------------------------\n`;
                    requirementsText += `‚Ä¢ Chapitres EN 301 549 applicables : 6 (TIC avec voix bidirectionnelle), 7 (TIC avec vid√©o)\n`;
                    formData.videoTypes.forEach(type => {
                        const label = t.videoTypes[type] || type;
                        requirementsText += `‚Ä¢ ${label} : Texte en temps r√©el, sous-titres et accessibilit√© de communication\n`;
                    });
                    if (formData.mediaRequirements.length > 0) {
                        requirementsText += `‚Ä¢ Fonctionnalit√©s d'accessibilit√© requises :\n`;
                        formData.mediaRequirements.forEach(req => {
                            const label = t.mediaRequirements[req] || req;
                            requirementsText += `  - ${label}\n`;
                        });
                    }
                    requirementsText += `\n`;
                }
                
                if (formData.supportTypes.length > 0) {
                    requirementsText += `EXIGENCES DE SOUTIEN ET DOCUMENTATION\n`;
                    requirementsText += `------------------------------------\n`;
                    requirementsText += `‚Ä¢ Chapitres EN 301 549 applicables : 12 (Documentation et soutien)\n`;
                    formData.supportTypes.forEach(type => {
                        const label = t.supportTypes[type] || type;
                        requirementsText += `‚Ä¢ ${label} : Format et livraison accessibles requis\n`;
                    });
                    requirementsText += `\n`;
                }
                
                requirementsText += `EXIGENCES D'APPROVISIONNEMENT ET VALIDATION\n`;
                requirementsText += `-------------------------------------------\n`;
                requirementsText += `‚Ä¢ Le fournisseur doit fournir un Rapport de conformit√© d'accessibilit√© (RCA) actuel\n`;
                requirementsText += `‚Ä¢ Le RCA doit √™tre au format OpenACR (versions HTML et YAML)\n`;
                requirementsText += `‚Ä¢ Des tests d'accessibilit√© ind√©pendants peuvent √™tre requis\n`;
                requirementsText += `‚Ä¢ Surveillance de conformit√© continue pendant toute la p√©riode contractuelle\n`;
                requirementsText += `‚Ä¢ Plan de correction requis pour toute non-conformit√© identifi√©e\n\n`;
                
                requirementsText += `STATUT D'EXEMPTION\n`;
                requirementsText += `------------------\n`;
                const exemptionLabel = t.exemptions[formData.exemption] || formData.exemption || 'Non sp√©cifi√©';
                requirementsText += `Exemption : ${exemptionLabel}\n\n`;
                
                requirementsText += `PHASE D'APPROVISIONNEMENT\n`;
                requirementsText += `-------------------------\n`;
                const phaseLabel = t.procurementPhases[formData.procurementPhase] || formData.procurementPhase || 'Non sp√©cifi√©';
                requirementsText += `Phase actuelle : ${phaseLabel}\n\n`;
                
                requirementsText += `NORMES DE R√âF√âRENCE\n`;
                requirementsText += `-------------------\n`;
                requirementsText += `‚Ä¢ EN 301 549 v3.2.1 (2021) : https://www.etsi.org/deliver/etsi_en/301500_301599/301549/03.02.01_60/en_301549v030201p.pdf\n`;
                requirementsText += `‚Ä¢ WCAG 2.1 : https://www.w3.org/TR/WCAG21/\n`;
                requirementsText += `‚Ä¢ Conseils suppl√©mentaires : https://accessible.canada.ca/\n`;
            }
            
            // Display the requirements
            displayRequirements({
                text: requirementsText,
                data: formData
            });
        }
        
        // --- SAVE/LOAD FUNCTIONALITY ---
        function saveFormData() {
            const formData = collectFormData();
            const dataStr = JSON.stringify(formData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const projectName = formData.projectName || 'Project';
            const sanitizedProjectName = projectName.replace(/[^a-zA-Z0-9\-_]/g, '_');
            const filename = `EN301549-${sanitizedProjectName}-${new Date().toISOString().split('T')[0]}.json`;
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = filename;
            link.click();
            
            URL.revokeObjectURL(link.href);
            alert('Form data saved successfully!');
        }
        
        function loadFormData(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/json') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        populateFormFromData(data);
                        alert('Form data loaded successfully!');
                    } catch (error) {
                        alert('Error loading form data: Invalid JSON file');
                    }
                };
                reader.readAsText(file);
            } else {
                alert('Please select a valid JSON file');
            }
            event.target.value = ''; // Clear the file input
        }
        
        function populateFormFromData(data) {
            // Clear all form fields first
            document.querySelectorAll('input[type="radio"]').forEach(radio => radio.checked = false);
            document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => checkbox.checked = false);
            
            // Set project name
            if (data.projectName) {
                document.getElementById('projectName').value = data.projectName;
            }
            
            // Set radio button selections
            const radioGroups = ['procurementPhase', 'exemption', 'webContent', 'wcagLevel', 'publicWebsite', 'authoringCapability', 'closedFunctionality'];
            radioGroups.forEach(groupName => {
                if (data[groupName]) {
                    const radio = document.querySelector(`input[name="${groupName}"][value="${data[groupName]}"]`);
                    if (radio) radio.checked = true;
                }
            });
            
            // Set checkbox selections
            const checkboxGroupMap = {
                ictTypes: 'ictType',
                softwareTypes: 'softwareType',
                hardwareCategories: 'hardwareCategory',
                videoTypes: 'videoType',
                mediaRequirements: 'mediaRequirements',
                supportTypes: 'supportType'
            };
            
            Object.entries(checkboxGroupMap).forEach(([groupName, singularName]) => {
                if (data[groupName] && Array.isArray(data[groupName])) {
                    data[groupName].forEach(value => {
                        const checkbox = document.querySelector(`input[name="${singularName}"][value="${value}"]`);
                        if (checkbox) checkbox.checked = true;
                    });
                }
            });
            
            // Set website URL
            if (data.websiteURL) {
                const websiteInput = document.getElementById('websiteURL');
                if (websiteInput) websiteInput.value = data.websiteURL;
            }
            
            // Update conditional displays
            updateConditionalDisplays();
            
            // Clear any error messages
            const errorDiv = document.getElementById('formErrorMessages');
            if (errorDiv) errorDiv.innerHTML = '';
        }
        
        // --- URL PARAMETER HANDLING ---
        function populateFormFromURL() {
            const urlParams = new URLSearchParams(window.location.search);

            // Project Name
            if (urlParams.has('projectName')) {
                const projectNameInput = document.getElementById('projectName');
                if (projectNameInput) {
                    projectNameInput.value = urlParams.get('projectName');
                }
            }

            // Radio Buttons
            const radioGroups = ['procurementPhase', 'exemption', 'webContent', 'wcagLevel', 'publicWebsite', 'authoringCapability', 'closedFunctionality'];
            radioGroups.forEach(groupName => {
                if (urlParams.has(groupName)) {
                    const value = urlParams.get(groupName);
                    const radio = document.querySelector(`input[name="${groupName}"][value="${value}"]`);
                    if (radio) {
                        radio.checked = true;
                        radio.dispatchEvent(new Event('change'));
                    }
                }
            });

            // Checkboxes - handle multiple values
            const checkboxGroups = ['ictType', 'softwareType', 'hardwareCategory', 'videoType', 'mediaRequirements', 'supportType'];
            checkboxGroups.forEach(groupName => {
                // First, uncheck all in the group
                document.querySelectorAll(`input[name="${groupName}"]`).forEach(checkbox => {
                    checkbox.checked = false;
                });

                if (urlParams.has(groupName)) {
                    const values = urlParams.getAll(groupName);
                    values.forEach(value => {
                        const checkbox = document.querySelector(`input[name="${groupName}"][value="${value}"]`);
                        if (checkbox) {
                            checkbox.checked = true;
                            checkbox.dispatchEvent(new Event('change'));
                        }
                    });
                } else {
                    // If parameter is missing, check 'none' option by default if it exists
                    const noneCheckbox = document.querySelector(`input[name="${groupName}"][value="none"]`);
                    if (noneCheckbox) {
                        noneCheckbox.checked = true;
                        noneCheckbox.dispatchEvent(new Event('change'));
                    }
                }
            });

            // Website URL
            if (urlParams.has('websiteURL')) {
                const websiteURLInput = document.getElementById('websiteURL');
                if (websiteURLInput) {
                    websiteURLInput.value = urlParams.get('websiteURL');
                }
            }
        }

        function updateURLFromForm() {
            const formData = collectFormData();
            const urlParams = new URLSearchParams();

            // Add project name
            if (formData.projectName) {
                urlParams.set('projectName', formData.projectName);
            }

            // Add radio button values
            const radioFields = ['procurementPhase', 'exemption', 'webContent', 'wcagLevel', 'publicWebsite', 'authoringCapability', 'closedFunctionality'];
            radioFields.forEach(field => {
                if (formData[field]) {
                    urlParams.set(field, formData[field]);
                }
            });

            // Add checkbox arrays
            const checkboxFields = [
                { data: 'ictTypes', param: 'ictType' },
                { data: 'softwareTypes', param: 'softwareType' },
                { data: 'hardwareCategories', param: 'hardwareCategory' },
                { data: 'videoTypes', param: 'videoType' },
                { data: 'mediaRequirements', param: 'mediaRequirements' },
                { data: 'supportTypes', param: 'supportType' }
            ];

            checkboxFields.forEach(field => {
                if (formData[field.data] && formData[field.data].length > 0) {
                    formData[field.data].forEach(value => {
                        urlParams.append(field.param, value);
                    });
                }
            });

            // Add website URL
            if (formData.websiteURL) {
                urlParams.set('websiteURL', formData.websiteURL);
            }

            // Update URL without page reload
            const newURL = window.location.pathname + '?' + urlParams.toString();
            window.history.replaceState({}, '', newURL);
        }

        // --- "NONE OF THE ABOVE" HANDLING ---
        function setupNoneHandling() {
            const checkboxGroups = ['softwareType', 'hardwareCategory', 'videoType', 'supportType'];
            
            checkboxGroups.forEach(groupName => {
                const noneCheckbox = document.querySelector(`input[name="${groupName}"][value="none"]`);
                const otherCheckboxes = Array.from(document.querySelectorAll(`input[name="${groupName}"]:not([value="none"])`));
                
                if (noneCheckbox && otherCheckboxes.length > 0) {
                    // When "none" is checked, uncheck all others
                    noneCheckbox.addEventListener('change', function() {
                        if (this.checked) {
                            otherCheckboxes.forEach(cb => {
                                cb.checked = false;
                            });
                        }
                        updateURLFromForm();
                    });
                    
                    // When any other is checked, uncheck "none"
                    otherCheckboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', function() {
                            if (this.checked && noneCheckbox.checked) {
                                noneCheckbox.checked = false;
                            }
                            updateURLFromForm();
                        });
                    });
                }
            });
        }

        // --- LANGUAGE SWITCHER AND EVENT HANDLERS ---
        document.addEventListener('DOMContentLoaded', function() {
            renderForm();
            
            document.getElementById('langSwitcher').addEventListener('change', function(e) {
                currentLang = e.target.value;
                renderForm();
                setDefaultValues(); // Re-apply defaults after language change
                populateFormFromURL(); // Reapply URL parameters after language change
                setupNoneHandling(); // Re-setup "None of the above" logic
                // Optionally rerender output if present
                if (window.currentRequirements) {
                    displayRequirements(window.currentRequirements);
                }
            });

            // Add form change listeners to update URL parameters
            document.addEventListener('change', function(e) {
                if (e.target.matches('input, select, textarea')) {
                    setTimeout(updateURLFromForm, 100); // Small delay to ensure form data is updated
                }
            });
        });

    </script>
</body>
</html>
